## Overview
Without some kind of third-party authentication library it's impossible to access client-encrypted resources on S3 using the `#presigned_url` helper from `Aws::SDK v2` because Rails or some agent on our server has to decrypt the envelope stored alongside the resource on S3 prior to fetching the decrypted resource.

Because we can't use the `#presigned_url` method on AWS we need to implement some kind of very secure limited-access authentication service in order to download these files. Thus we created the `SecureToken` model to handle such one-off authentications.

## SecureToken

### Encryption Protocol
`SecureToken` uses `scrypt` for authentication which, to date, is the safest cryptographic platform in existence and as of right now there are no reported instances of it having been cracked. Here's a chart demonstrating the amount of hardware that would be required to crack passwords encrypted with 'scrypt', 'bcrypt', 'PBKDF2', and 'MD5' algorithms:

![image](https://cloud.githubusercontent.com/assets/95957/13638914/af19e6a6-e60e-11e5-87df-06d5e274f622.png)

For reference the `(time)` amounts in parenthesis are the maximum decryption durations being used in those scenarios in order hinder the effectiveness of brute-force attacks. We're using a maximum decryption time of 1 second which is the default of the `scrypt` gem for ruby (https://github.com/pbhogan/scrypt), and is ample.

The maximum password length demonstrated in the chart above is 80-characters long. We're using a url-safe 254-character base-64 password (190 bit) generated via ruby's `SecureRandom` library:

```
SecureRandom.urlsafe_base64(190)
```

To make matters a bit worse for attackers we're using 512-bit `scrypt` encryption, which produces a hex hash of between 1049 and 1050 characters. It's also worth noting that because `scrypt` is a 'one way' encryption algorithm even if an attacker had the 512-bit encrypted hash in their possession it would be impossible to decrypt the original password used. The only way to authenticate against the encrypted hash is to guess the correct, random 254 character password that was used to generate it in the first place. 

### Workflow
The overall authentication process here is as such:

1. User requests a `SubmissionsExport` archive.

2. If the archive generates successfully, the `SubmissionsExportPerformer` generates a new `SecureToken` object which contains a hashed 190-bit password and a unique 36-character uuid (also generated by `SecureRandom`) which can used to locate the `SecureToken` so we don't have to betray the resource name or id in the secret url emailed to the user.

3. The user receives an email with a link to the resource which contains the `uuid` for the `SecureToken` as well as the 190-bit password (called `secret_key` across the remainder implementation).

4. The user clicks the link, which directs the request to the `SubmissionsExportsController#secure_download` method, which has been stripped of all other normal system authentication and replaced only with authentication from `SecureToken`.

5. The `SecureTokenAuthenticator` class accepts the `uuid` and the `secret_key` from the request and authenticates the secure token against them.

6. If the `secret_key` successfully authenticates against the `encrypted_key` in the `SecureToken` associated with the given `uuid`, then the request is authenticated, and the decrypted S3 resource is streamed via `send_file` in the `SubmissionsExport` controller. If the authentication fails because the `SecureToken` has expired (secure tokens are currently only valid for one week), then we redirect the user to the GradeCraft homepage and notify them of this. Otherwise they're just redirected to the homepage and given a vague 'your request was not successful' notice.

### Slowdown
It should also be noted that the usage of incorrectly formatted `uuid` or `secret_key` values submitted in requests also prompt a one-second slowdown of the response in order to hinder brute-force attacks that might be using random values for either of these attributes.

### Notes
Currently all `SecureToken` objects are being created with an `expired_at` time of one week from the created_at date. It may be desirable to modify this in the future. 
